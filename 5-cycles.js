// Типи циклів
// 1. for
// Використовується, коли заздалегідь відомо кількість ітерацій.

// Синтаксис:
//for (ініціалізація; умова; оновлення) {
//  // Код для виконання
//}
//Приклад:
for (let i = 0; i < 5; i++) {
    console.log(`Ітерація ${i}`);
}
// Результат: Ітерація 0, Ітерація 1, ..., Ітерація 4

// Ініціалізація: задається змінна(зазвичай лічильник).
// Умова: перевіряється перед кожною ітерацією. Якщо true,
// виконується тіло циклу.
// Оновлення: виконується після кожної ітерації (наприклад,
// збільшення лічильника).

// 2. while
// Використовується, коли невідомо, скільки ітерацій буде
// потрібно, але є умова для продовження.

//Синтаксис:
//while (умова) {
//  // Код для виконання
//}
// Приклад:
let i = 0;
while (i < 5) {
    console.log(`Ітерація ${i}`);
    i++;
}
// Результат: Ітерація 0, Ітерація 1, ..., Ітерація 4
// Цикл працює, поки умова true.
// 3. do...while
// Схожий на while, але виконує тіло циклу хоча б один раз, навіть якщо умова false.

// Синтаксис:
// do {
//   // Код для виконання
// } while (умова);
// Приклад:
do {
    console.log(`Ітерація ${i}`);
    i++;
} while (i < 5);
// Результат: Ітерація 0, Ітерація 1, ..., Ітерація 4
// 4. for...of
// Призначений для ітерації по ітеративних об'єктах
// (масиви, рядки, набори тощо).

// Синтаксис:
// for (const item of iterable) {
//   // Код для виконання
// }
// Приклад:
const numbers1 = [10, 20, 30];
for (const num of numbers1) {
    console.log(num);
}
// Результат: 10, 20, 30
// Зручно використовувати, якщо не потрібен індекс.
// 5. for...in
// Призначений для ітерації по властивостях об'єкта (ключах).

// Синтаксис:
// for (const key in object) {
//   // Код для виконання
// }
// Приклад:
const user = { name: "Іван", age: 30 };
for (const key in user) {
    console.log(`${key}: ${user[key]}`);
}
// Результат: name: Іван, age: 30
// Використовується для об'єктів, але не підходить для
// масивів(індекси теж будуть розглядатися як ключі).

// 6. Вихід із циклу: break
// Дозволяє достроково завершити виконання циклу.

// Приклад:
for (let i = 0; i < 10; i++) {
    if (i === 5) break;
    console.log(i);
}
// Результат: 0, 1, 2, 3, 4
// 7. Пропуск ітерації: continue
// Дозволяє пропустити поточну ітерацію і перейти до наступної.

// Приклад:
for (let i = 0; i < 10; i++) {
    if (i % 2 === 0) continue; // Пропустити парні числа
    console.log(i);
}
// Результат: 1, 3, 5, 7, 9
// 8. Вкладені цикли
// Цикли можуть бути вкладені один в інший, наприклад,
// для роботи з багатовимірними масивами.

// Приклад:
for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 2; j++) {
        console.log(`i = ${i}, j = ${j}`);
    }
}
// Результат:
// i = 0, j = 0
// i = 0, j = 1
// ...

// 9. Методи для ітерації (замість циклів)
// У сучасному JavaScript часто використовуються методи для
// ітерації, наприклад:

// forEach:
const arr = [10, 20, 30];
arr.forEach((num) => console.log(num));
// Результат: 10, 20, 30
// map:
const doubled1 = arr.map((num) => num * 2);
console.log(doubled1);
// Результат: [20, 40, 60]
// filter:
const filtered = arr.filter((num) => num > 15);
console.log(filtered);
// Результат: [20, 30]
// Типові помилки в циклах:
// Нескінченний цикл: Забули змінити змінну, яка контролює умову.

// while (true) {
//     // Умова завжди true
//     console.log(i);
//     i++; // Якщо це забути, цикл ніколи не завершиться
// }
// Неправильний індекс у масивах: Вихід за межі масиву:

const arr2 = [1, 2, 3];
for (let i = 0; i <= arr.length; i++) {
    console.log(arr2[i]); // arr[3] буде undefined
}
// Використання for...in для масивів: Отримаєте індекси як ключі замість значень.
//
// Коли використовувати різні цикли:
// for — коли відома кількість ітерацій.
// while — коли кількість ітерацій залежить від умови.
// do...while — коли код потрібно виконати хоча б раз.
// for...of — для ітерації по масивах, рядках, наборах.
// for...in — для ітерації по властивостях об'єкта.

// Коли краще використовувати forEach, map, і filter?
// 1. forEach
// Використовується для виконання дій над кожним елементом
// масиву, але не повертає новий масив.Це чисто метод для
// побічних ефектів.

// Коли використовувати:
// Якщо потрібно виконати певну дію з кожним елементом
// масиву(логування, оновлення змінної тощо).
// Якщо не потрібен результат у вигляді нового масиву.
// Приклад:
const numbers2 = [1, 2, 3];
numbers2.forEach((num) => console.log(num * 2));
// Результат у консолі: 2, 4, 6
//❗ Не використовуй forEach, якщо потрібен новий масив.

// 2. map
// Призначений для перетворення масиву: він створює новий
// масив на основі результатів виконання функції для кожного
// елемента.

// Коли використовувати:
// Якщо потрібно перетворити або модифікувати кожен елемент масиву.
// Якщо потрібен результат у вигляді нового масиву.
// Приклад:
const numbers3 = [1, 2, 3];
const doubled2 = numbers3.map((num) => num * 2);
console.log(doubled2);
// Результат: [2, 4, 6]
// ❗ Не використовуй map, якщо тобі не потрібен новий масив. У такому випадку краще використовувати forEach.

// 3. filter
// Призначений для фільтрації масиву: створює новий масив,
// який містить лише ті елементи, що відповідають умові.

// Коли використовувати:
// Якщо потрібно отримати підмножину елементів, які відповідають
// певній умові.
// Приклад:
const numbers4 = [1, 2, 3, 4];
const evenNumbers = numbers4.filter((num) => num % 2 === 0);
console.log(evenNumbers);
// Результат: [2, 4]
// ❗ Не використовуй filter, якщо не потрібен новий масив.

// Порівняння: forEach, map, filter
// Методи	Повертає значення?	Використовувати для
// forEach	Нічого (undefined)	Побічні ефекти (логування, зміна змінної).
// map	Новий масив	Перетворення або модифікація елементів.
// filter	Новий масив з відфільтрованими елементами	Фільтрація за умовою.
// Кілька порад для використання:
// Коли віддавати перевагу forEach:
// Логування кожного елемента:

const users = ["Іван", "Марія", "Олег"];
users.forEach((user) => console.log(`Привіт, ${user}!`));
// Оновлення змінної (сумування, підрахунок):

const numbers5 = [1, 2, 3];
let sum = 0;
numbers5.forEach((num) => (sum += num));
console.log(sum); // Результат: 6
// Коли віддавати перевагу map:
// Створення нового масиву з модифікованими елементами:
const numbers6 = [1, 2, 3];
const squared = numbers6.map((num) => num ** 2);
console.log(squared); // Результат: [1, 4, 9]
// Коли віддавати перевагу filter:
// Вибір елементів за умовою:
const ages = [12, 18, 25, 15, 30];
const adults = ages.filter((age) => age >= 18);
console.log(adults); // Результат: [18, 25, 30]
// Чи можна обійтись циклами?
// Так, усе, що роблять forEach, map, і filter, можна виконати через for або while. Але:
// Методи коротші та більш читабельні.
// Зменшується кількість помилок. Наприклад, не треба вручну додавати елементи в новий масив.
// Приклад без map:
const numbers7 = [1, 2, 3];
const doubled3 = [];
for (let i = 0; i < numbers7.length; i++) {
    doubled3.push(numbers[i] * 2);
}
console.log(doubled); // Результат: [2, 4, 6]
// Те саме з map:
const numbers = [1, 2, 3];
const doubled = numbers.map((num) => num * 2);
console.log(doubled); // Результат: [2, 4, 6]
